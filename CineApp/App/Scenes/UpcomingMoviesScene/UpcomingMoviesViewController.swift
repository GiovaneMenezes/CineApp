//
//  UpcomingMoviesViewController.swift
//  CineApp
//
//  Created by Giovane Silva de Menezes Cavalcante on 05/01/19.
//  Copyright (c) 2019 GSMenezes. All rights reserved.
//
//  This file was generated by the Clean Swift HELM Xcode Templates
//  https://github.com/HelmMobile/clean-swift-templates

import UIKit

protocol UpcomingMoviesViewControllerInput {
    func showFetchedMovies(viewModel: UpcomingMoviesScene.FetchMovies.ViewModel)
    func showSelectedMovie(viewModel: UpcomingMoviesScene.SelectMovie.ViewModel)
}

protocol UpcomingMoviesViewControllerOutput {
    func fetchMovies(request: UpcomingMoviesScene.FetchMovies.Request)
    func selectMovie(request: UpcomingMoviesScene.SelectMovie.Request)
}

class UpcomingMoviesViewController: UIViewController, UpcomingMoviesViewControllerInput {
    
    @IBOutlet weak var upcomingMoviesCollectionView: UICollectionView!
    
    var output: UpcomingMoviesViewControllerOutput?
    var router: UpcomingMoviesRouter?
    var errorState: Bool = false
    
    var cellModels: [UpcomingMoviesScene.FetchMovies.ViewModel.CellModel] = []
    
    // MARK: Object lifecycle
    
    override func awakeFromNib() {
        super.awakeFromNib()
        UpcomingMoviesConfigurator.sharedInstance.configure(viewController: self)
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        registerCells()
        fetchMovies()
    }
    
    // MARK: Requests
    
    func fetchMovies() {
        let request = UpcomingMoviesScene.FetchMovies.Request()
        output?.fetchMovies(request: request)
    }
    
    func selectMovie(index: Int) {
        let request = UpcomingMoviesScene.SelectMovie.Request(index: index)
        output?.selectMovie(request: request)
    }
    
    // MARK: Display logic
    
    func showFetchedMovies(viewModel: UpcomingMoviesScene.FetchMovies.ViewModel) {
        switch viewModel.state {
        case .success(let cellModels):
            handleShowFetchedMoviesSuccess(cellModels: cellModels)
        case .failure(let error):
            handleShowFetchedMoviesFailure(errorMessage: error)
        }
    }
    
    func showSelectedMovie(viewModel: UpcomingMoviesScene.SelectMovie.ViewModel) {
        router?.navigateToMovieDetailViewController()
    }
    
    // MARK: Handlers
    
    func handleShowFetchedMoviesSuccess(cellModels: [UpcomingMoviesScene.FetchMovies.ViewModel.CellModel]) {
        self.cellModels = cellModels
        upcomingMoviesCollectionView.reloadData()
    }
    
    func handleShowFetchedMoviesFailure(errorMessage: String) {
        errorState = true
        upcomingMoviesCollectionView.reloadSections(IndexSet(integer: 1))
        print(errorMessage)
    }
    
    // MARK: Convenience Methods
    
    func registerCells() {
        let loadingCellIdentifier = LoadingCollectionViewCell.cellIdentifier
        let loadingCell = UINib(nibName: loadingCellIdentifier, bundle: nil)
        upcomingMoviesCollectionView.register(loadingCell, forCellWithReuseIdentifier: loadingCellIdentifier)
    }
    
    @IBAction func searchButtonTapped(_ sender: Any) {
        router?.navigateToSearchButtonViewController()
    }
}

//This should be on configurator but for some reason storyboard doesn't detect ViewController's name if placed there
extension UpcomingMoviesViewController: UpcomingMoviesPresenterOutput {
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        router?.passDataToNextScene(for: segue)
    }
}

extension UpcomingMoviesViewController: UICollectionViewDelegateFlowLayout {
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        selectMovie(index: indexPath.row)
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        if indexPath.section == 0 {
            return CGSize(width: collectionView.bounds.width, height: 285)
        } else if errorState || cellModels.isEmpty {
            return .zero
        } else {
            return CGSize(width: collectionView.bounds.width, height: 100)
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        if indexPath.section == 1 {
            if errorState || cellModels.isEmpty {
                cell.isHidden = true
            } else {
                cell.isHidden = false
            }
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, didEndDisplaying cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        guard indexPath.row > cellModels.count - 5, !errorState else { return }
        fetchMovies()
    }
}

extension UpcomingMoviesViewController: UICollectionViewDataSource {
    
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 2
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return section == 0 ? cellModels.count : 1
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if indexPath.section == 0 {
            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "UpcomingMovieCell", for: indexPath) as? UpcomingMovieCollectionViewCell else { return UICollectionViewCell()}
            cell.fill(model: cellModels[indexPath.row])
            return cell
        } else {
            return collectionView.dequeueReusableCell(withReuseIdentifier: LoadingCollectionViewCell.cellIdentifier, for: indexPath)
        }
    }
}
